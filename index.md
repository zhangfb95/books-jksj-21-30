## 24-Java并发编程实战（完结）
+ 02-学习攻略 (1讲)
    + [学习攻略如何才能学好并发编程？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/02-学习攻略 (1讲)/学习攻略如何才能学好并发编程？.html)
+ 08-结束语 (1讲)
    + [结束语丨十年之后，初心依旧.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/08-结束语 (1讲)/结束语丨十年之后，初心依旧.html)
+ 06-第四部分：案例分析 (4讲)
    + [41丨案例分析（四）：高性能数据库连接池HiKariCP.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/06-第四部分：案例分析 (4讲)/41丨案例分析（四）：高性能数据库连接池HiKariCP.html)
    + [39丨案例分析（二）：高性能网络应用框架Netty.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/06-第四部分：案例分析 (4讲)/39丨案例分析（二）：高性能网络应用框架Netty.html)
    + [40丨案例分析（三）：高性能队列Disruptor.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/06-第四部分：案例分析 (4讲)/40丨案例分析（三）：高性能队列Disruptor.html)
    + [38丨案例分析（一）：高性能限流器Guava 丨RateLimiter.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/06-第四部分：案例分析 (4讲)/38丨案例分析（一）：高性能限流器Guava 丨RateLimiter.html)
+ 01-开篇词 (1讲)
    + [00丨开篇词你为什么需要学习并发编程？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/01-开篇词 (1讲)/00丨开篇词你为什么需要学习并发编程？.html)
+ 03-第一部分：并发理论基础 (13讲)
    + [13丨理论基础模块热点问题答疑.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/13丨理论基础模块热点问题答疑.html)
    + [10丨Java线程（中）：创建多少线程才是合适的？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/10丨Java线程（中）：创建多少线程才是合适的？.html)
    + [11丨Java线程（下）：为什么局部变量是线程安全的？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/11丨Java线程（下）：为什么局部变量是线程安全的？.html)
    + [05丨一不小心就死锁了，怎么办？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/05丨一不小心就死锁了，怎么办？.html)
    + [12丨如何用面向对象思想写好并发程序？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/12丨如何用面向对象思想写好并发程序？.html)
    + [07丨安全性、活跃性以及性能问题.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/07丨安全性、活跃性以及性能问题.html)
    + [01丨可见性、原子性和有序性问题：并发编程Bug的源头.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/01丨可见性、原子性和有序性问题：并发编程Bug的源头.html)
    + [02丨Java内存模型：看Java如何解决可见性和有序性问题.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/02丨Java内存模型：看Java如何解决可见性和有序性问题.html)
    + [06丨用“等待-通知”机制优化循环等待.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/06丨用“等待-通知”机制优化循环等待.html)
    + [09丨Java线程（上）：Java线程的生命周期.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/09丨Java线程（上）：Java线程的生命周期.html)
    + [08丨管程：并发编程的万能钥匙.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/08丨管程：并发编程的万能钥匙.html)
    + [03丨互斥锁（上）：解决原子性问题.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/03丨互斥锁（上）：解决原子性问题.html)
    + [04丨互斥锁（下）：如何用一把锁保护多个资源？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/03-第一部分：并发理论基础 (13讲)/04丨互斥锁（下）：如何用一把锁保护多个资源？.html)
+ 07-第五部分：其他并发模型 (4讲)
    + [45丨CSP模型：Golang的主力队员.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/07-第五部分：其他并发模型 (4讲)/45丨CSP模型：Golang的主力队员.html)
    + [42丨Actor模型：面向对象原生的并发模型.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/07-第五部分：其他并发模型 (4讲)/42丨Actor模型：面向对象原生的并发模型.html)
    + [44丨协程：更轻量级的线程.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/07-第五部分：其他并发模型 (4讲)/44丨协程：更轻量级的线程.html)
    + [43丨软件事务内存：借鉴数据库的并发经验.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/07-第五部分：其他并发模型 (4讲)/43丨软件事务内存：借鉴数据库的并发经验.html)
+ 04-第二部分：并发工具类 (14讲)
    + [25丨CompletionService：如何批量执行异步任务？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/25丨CompletionService：如何批量执行异步任务？.html)
    + [17丨ReadWriteLock：如何快速实现一个完备的缓存？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/17丨ReadWriteLock：如何快速实现一个完备的缓存？.html)
    + [15丨Lock和Condition（下）：D34Worker 丨Thread模式：如何避免重复创建线程？ubbo如何用管程实现异步转同步.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/15丨Lock和Condition（下）：D34Worker 丨Thread模式：如何避免重复创建线程？ubbo如何用管程实现异步转同步.html)
    + [14丨Lock和Condition（上）：隐藏在并发包中的管程.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/14丨Lock和Condition（上）：隐藏在并发包中的管程.html)
    + [24丨CompletableFuture：异步编程没那么难.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/24丨CompletableFuture：异步编程没那么难.html)
    + [23丨Future：如何用多线程实现最优的“烧水泡茶”程序？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/23丨Future：如何用多线程实现最优的“烧水泡茶”程序？.html)
    + [19丨丨CountDownLatch和CyclicBarrier：如何让多线程步调一致？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/19丨丨CountDownLatch和CyclicBarrier：如何让多线程步调一致？.html)
    + [20丨并发容器：都有哪些“坑”需要我们填？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/20丨并发容器：都有哪些“坑”需要我们填？.html)
    + [27丨并发工具类模块热点问题答疑.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/27丨并发工具类模块热点问题答疑.html)
    + [16丨Semaphore：如何快速实现一个限流器？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/16丨Semaphore：如何快速实现一个限流器？.html)
    + [18丨丨StampedLock：有没有比读写锁更快的锁？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/18丨丨StampedLock：有没有比读写锁更快的锁？.html)
    + [26丨Fork-Join：单机版的MapReduce.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/26丨Fork-Join：单机版的MapReduce.html)
    + [22丨Executor与线程池：如何创建正确的线程池？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/22丨Executor与线程池：如何创建正确的线程池？.html)
    + [21丨原子类：无锁工具类的典范.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/04-第二部分：并发工具类 (14讲)/21丨原子类：无锁工具类的典范.html)
+ 05-第三部分：并发设计模式 (10讲)
    + [29丨Copy-on-Write模式：不是延时策略的COW.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/29丨Copy-on-Write模式：不是延时策略的COW.html)
    + [28丨Immutability模式：如何利用不变性解决并发问题？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/28丨Immutability模式：如何利用不变性解决并发问题？.html)
    + [36丨生产者-消费者模式：用流水线思想提高效率.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/36丨生产者-消费者模式：用流水线思想提高效率.html)
    + [35丨两阶段终止模式：如何优雅地终止线程？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/35丨两阶段终止模式：如何优雅地终止线程？.html)
    + [34丨Worker 丨Thread模式：如何避免重复创建线程？.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/34丨Worker 丨Thread模式：如何避免重复创建线程？.html)
    + [32丨Balking模式：再谈线程安全的单例模式.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/32丨Balking模式：再谈线程安全的单例模式.html)
    + [30丨线程本地存储模式：没有共享，就没有伤害.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/30丨线程本地存储模式：没有共享，就没有伤害.html)
    + [33丨Thread-Per-Message模式：最简单实用的分工方法.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/33丨Thread-Per-Message模式：最简单实用的分工方法.html)
    + [37丨设计模式模块热点问题答疑.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/37丨设计模式模块热点问题答疑.html)
    + [31丨Guarded 丨Suspension模式：等待唤醒机制的规范实现.html](http://juconcurrent.com/books-jksj-21-30/24-Java并发编程实战（完结）/05-第三部分：并发设计模式 (10讲)/31丨Guarded 丨Suspension模式：等待唤醒机制的规范实现.html)